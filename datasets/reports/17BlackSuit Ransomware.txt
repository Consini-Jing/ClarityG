In December 2023, we observed an intrusion that started with the execution of a Cobalt Strike beacon and ended in the deployment of BlackSuit ransomware.
The threat actor leveraged various tools, including Sharphound, Rubeus, SystemBC, Get-DataInfo.ps1, Cobalt Strike, and ADFind, along with built-in system tools.
Command and control traffic was proxied through CloudFlare to conceal their Cobalt Strike server.
Fifteen days after initial access, BlackSuit ransomware was deployed by copying files over SMB to admin shares and executing them through RDP sessions.
Three rules were added to our private ruleset related to this case.
The intrusion began in December 2023, with the initial sign being the execution of an unusually large-sized Cobalt Strike beacon.
After the beacon’s execution, there was no immediate follow-up activity.
The initial access delivery method for the intrusion remains unclear, as there was no evidence available.
The Cobalt Strike C2 traffic beaconed to IP addresses managed by CloudFlare, which acted as proxy server between the victim network and their team server.
Approximately six hours after the initial execution, the threat actor used Windows utilities, such as systeminfo and nltest to perform enumeration on the system and environment.
After, they conducted AS-REP Roasting and Kerberoasting attacks against two of the domain controllers, utilizing Rubeus, which was executed in memory via Cobalt Strike.
Following this, the threat actor ran Sharphound in memory through the Cobalt Strike beacon, and saved the output to disk.
Around ten minutes after the initial discovery, the threat actor carried out their first lateral movement.
They transferred a Cobalt Strike beacon via SMB and executed it through a service to compromise another workstation.
On that workstation, they accessed LSASS to obtain credentials from memory.
Throughout the second day of the intrusion, the threat actor deployed multiple Cobalt Strike beacons on workstations and servers and also used RDP for further lateral movement.
The threat actor deployed multiple SystemBC executables on one of the file servers.
The second executable, established persistence through a registry run key and opened a new command and control channel.
After a busy second day of activity, the intrusion went silent.
On the seventh day, the Cobalt Strike command and control domain stopped using CloudFlare and switched to an Amazon AWS IP address, for the remainder of the intrusion.
On the eighth day, the threat actors deployed a new PowerShell Cobalt Strike beacon on a domain controller, this time pointing to a separate command and control server.
After two days of inactivity, the intrusion resumed with more Cobalt Strike beacons being distributed, along with several RDP logins.
More discovery activity was noticed when Sharphound was executed again.
The threat actor attempted multiple times to run ADFind but failed in each instance.
Five days later, the threat actor returned to finalize their objectives.
This time, ADFind was executed successfully, followed by the execution of the PowerShell script Get-DataInfo.ps1.
The final step was the deployment of the BlackSuit ransomware binary, qwe.exe, which was distributed via SMB to remote systems through the C$ share.
The attacker then manually connected to these systems using RDP to execute the ransomware.
Upon execution, the ransomware used vssadmin to delete shadow copies before encrypting the hosts.
The Time to Ransomware (TTR) was just under 328 hours, spanning 15 calendar days, with files being encrypted and the BlackSuit ransom note left on desktops and folders across the systems.
The earliest sign of the threat actor’s presence was the execution of a Cobalt Strike beacon, identified as RtWin64.exe.
Despite thorough investigation, the initial access point for the beacon’s deployment could not be determined.
Cobalt Strike served as the primary tool utilized by the threat actor, with a particular focus on its capabilities that mimic Sysinternals PsExec.
These features, including psexec and psexec_psh, enable remote process execution across systems.
The psexec module functions by uploading a binary to the target system, then creating and launching a Windows service to execute the file.
The eventID 7045 in Windows System logs shows the services created on the system:
The psexec command spawned a rundll32.exe process.
The psexec_psh module doesn’t copy a binary to the target, but instead executes a PowerShell one-liner.
The pattern it uses is %COMSPEC% /b /c start /b /min powershell -nop -w hidden -encodedcommand …
Registry Run Key
To ensure persistent access to the environment, the threat actor created a run key named “socks5” within the Current User registry hive.
The registry key’s configuration indicated that PowerShell would be used to launch a SystemBC backdoor named socks32.exe.
Sysmon eventID 13 (Registry value set) shows changes to a registry key value:
One interesting thing to mention is that the registry value name socks5 created under the Run key is hard coded.
The data is a string (type REG_SZ) which starts with powershell.exe windowstyle -hidden Command concatenated with the current executable name, which is obtained using GetModuleFileNameA with a null hModule first parameter.
SystemBC possesses the ability to create scheduled tasks using COM, as demonstrated in the following example.
While other reports have noted SystemBC utilizing this feature, it likely wasn’t employed in our case, as no evidence of scheduled task creation was observed during our investigation.
It first uses the function CoCreateInstance to create an instance of an ITaskScheduler object and then call the method NewWorkItem to create a scheduled task.
On a workstation that the threat actor moved laterally to, we observed use of named pipes.
Usually, when observing this behavior from Cobalt Strike, this tends to be usage of the getsystem command to elevate privileges; however, in this case we observed the parent process to not be services.exe and the threat actor was already running as SYSTEM.
This activity was seen in correlation to pass-the-hash behavior listed in Lateral Movement.
The threat actor changed to the context of a domain administrator and then was observed moving laterally again using Cobalt Strike, so we attribute this activity to pass-the-hash command execution activity rather than getsystem.
The threat actor employed an encoded PowerShell command to modify the registry, enabling Remote Desktop Protocol (RDP) access to a file server.
Setting the registry key “HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server” DenyTSConnections to 0 will allow terminal server connections to the host.
Process Injection
Given the threat actor’s extensive use of Cobalt Strike beacons, we anticipated the use of process injection as a method of evading detection by hiding within legitimate processes.
Upon analyzing process injections and access patterns from Cobalt Strike-generated processes, we successfully identified the suspicious activity we were searching for.
These injections can then be confirmed using things like YARA memory scanning:
The threat actor undertook multiple actions to obtain valid credentials, primarily leveraging Rubeus as the key tool.
During our investigation, we discovered that Rubeus had been loaded into mstsc.exe—a process previously injected by Cobalt Strike—functioning as a CLR module.
AS-REP roasting was the first credential access activity performed by the threat actor.
This was done with Rubeus on the beachhead host targeting a domain controller.
Rubeus writing the result of AS-REP roasting output to a file:
Indications of AS-REP roasting can be found by looking for windows eventID 4768 on the target domain controller.
The request is for Authentication tickets(TGT) with “Pre-Authentication Type” set to 0, meaning no password is required.
A lot of Kerberos Authentication Tickets were requested during AS-REP Roasting:
The threat actor used Rubeus to conduct a Kerberoasting attack.
During this period of time, we observed numerous Kerberos ticket requests, specifically using encryption type 0x17, which corresponds to RC4 encryption.
These RC4 encryption requests coincided with the execution of Rubeus and targeted multiple accounts across the domain
Rubeus executed in memory by Cobalt Strike creating kerberoast output:
EventID 4769 on a domain controller showing request for tickets with weak encryption:
LSASS memory access
The threat actor accessed LSASS memory on a workstation with a specific access request of 0x1010, where 0x0010 is necessary to read memory using ReadProcessMemory.
This request originated from a process that had been injected with Cobalt Strike.
Sysmon eventID 10 shows mstsc.exe accessing lsass with the access mask 0x1010
Discovery plays a critical role for the threat actor in assessing the environment they have infiltrated.
Throughout the intrusion, the attacker conducted discovery activities across multiple systems, gathering valuable intelligence on the network and its assets.
Discovery began on the beachhead host approximately six hours after initial access.
The first command executed was “systeminfo,” aimed at gathering details about the local system.
Shortly after, the command “nltest /dclist” was issued to identify the domain controllers within the environment.
Once the threat actor identified the domain controllers, they wasted no time and promptly loaded Sharphound into memory via Cobalt Strike.
This allowed them to conduct further discovery activities within the environment, expanding their reconnaissance efforts.
We have some proof showing mstsc.exe loading Sharphound as a CLR(Common Language Runtime) module.
mstsc.exe is the child process of Cobalt Strike beacon RtWin64.exe.
The below screenshot taken from the EDR telemetry depicts that:
Output from Sharphound was stored in “C:\Windows\Temp\Dogi\”.
The recurring use of this directory aligns with behaviors documented in a different report, BazarCall to Conti Ransomware chain.
This suggests a potential operational signature or TTP (Tactics, Techniques, and Procedures) common to this threat actor group or its operators.
Based on the output files created, `it looks like it was run in default mode as described below.
Sysmon eventID 11 showing the files created:
Sharphound appeared to be running in its default mode, which involves enumerating local group memberships by querying the Windows Security Accounts Manager (SAM) database remotely through the samr pipe on the target host.
This pipe is exposed via the IPC$ share, and corresponding activity can be detected by monitoring Windows security events with event ID 5145.
A similar approach is used to discover logged-on users; however, in this case, Sharphound communicates with the srvsvc pipe, utilizing the Server Service Remote Protocol.
Windows eventlog eventID 5145 showing Sharphound enumeration activity:
When Sharphound enumerates the Active Directory through LDAP searches, it performs an excess amount of queries.
Sharphound executed in memory by Cobalt Strike, performing LDAP queries:
Sharphound was initially executed on the beachhead host.
Later in the intrusion, the threat actor ran Sharphound two more times, this time on a domain controller.
The output from the first run was saved to “C:\Windows\System32\”, while the second run’s results were directed to “C:\Perflogs\”.
Again Sysmon eventID 11 caught the files created by Sharphound:
Windows Security eventID 4799 shows Sharphound performing discovery on local security-enabled groups:
ADFind, a tool frequently used by threat actors, was also employed in this intrusion to conduct enumeration and discovery.
After gaining access to the second domain controller, the threat actor created “ADFind.exe” and “adf.bat” in an attempt to gather further Active Directory information.
Sysmon eventID 11 showing creation of ADFind.exe and adf.bat by Cobalt Strike:
A few seconds after creation of the files, the threat actor was eager to collect the desired information and executed adf.bat via cmd.exe:
No additional commands were observed after each batch file execution.
This indicates the operator may have encountered difficulties, as the batch file was executed twice within just over a minute of the initial attempt, suggesting potential issues or missteps during execution.
Sysmon eventID 11 shows the creation of the files with the output of ADFind:
It’s possible that the files ended up being empty, causing the threat actor to reconsider their approach.
About 15 minutes later, the operator tried running ADFind.exe directly from the command line, likely to verify whether the tool would execute properly.
After failing to determine the cause of the issue, the threat actor stayed quiet until the next day.
The operator likely made an error by trying to run “adf.bat” from “C:\Windows\System32\” when both “adf.bat” and “ADFind.exe” were actually located in “C:\Perflogs\adf\".
Because of this, “ADFind.exe” probably couldn’t be found as an executable in the wrong directory, leading to the error.
After several days, the threat actor decided to give ADFind another try.
This time, on the file server the operator was successful in running adf.bat correctly to find ADFind.exe and perform the desired discovery activity:
Sysmon eventID 1 showing threat actor running adf.bat:
The threat actor also used a PowerShell script to enumerate local systems.
Together with a batch script called “start.bat” the threat actor ran Get-DataInfo.ps1 on both a domain controller and a different servers in the environment.
We have seen this PowerShell script used several times before.
Interestingly, PowerShell was initiated using the start.bat file.
However, the start.bat file did not work as intended and passed the “method” parameter to the Get-DataInfo.ps1 script, which is not recognized as a valid parameter.
This behavior may have confused the operator at the keyboard, as well as the batch script that was run several times in a row on both servers.
Sysmon EventID 1 shows start.bat executes Get-DataInfo.ps1 with parameter method:
The start.bat script tries to set a variable called method to the discovery method chosen by the user if the method is not typed on the command line:
The issue with the script arises from the fact that the variable “method” does not receive the user-chosen value until after the IF condition is complete.
Additionally, the variable must be referenced as %method% to capture the user input correctly.
This oversight explains why the PowerShell command initiating Get-DataInfo.ps1 includes “method” as a parameter on the command line:
The below will end up running the Get-DataInfo.ps1 script in default mode:
The default mode will run the Test-LHost, Get-DiskInfo and Get-Software functions in the script before calling the last function, Compress-Result:
Sysmon eventID 1 showing the execution:
Sysmon eventID 1 process create showing several runs of start.bat:
The threat actor performed several discovery commands using various Windows utilities at various times during the intrusion.
C:\Windows\system32\\cmd.exe /C systeminfo
C:\Windows\system32\cmd.exe /C net group "domain admins" /domain
C:\Windows\system32\cmd.exe /C nltest /dclist <domainname redacted>
nltest  /domain_trusts /all_trusts
C:\Windows\system32\cmd.exe /C net group "enterprise admins" /domain
C:\Windows\system32\cmd.exe /C ping <hostname redacted>
C:\Windows\system32\taskmgr.exe /4
C:\Windows\system32\cmd.exe /C All windows Import-Module ActiveDirectory Get-ADComputer -Filter {enabled -eq $true} -properties *|select Name, DNSHostName, OperatingSystem, LastLogonDate, IPv4Address | Export-CSV C:\Users\AllWindows.csv -NoTypeInformation -Encoding UTF8
C:\Windows\system32\cmd.exe /C route print
C:\Windows\system32\cmd.exe /C ping http://<IP redacted>/
On the final day of the intrusion, the threat actor accessed the administrative consoles for both DNS and Group Policy.
Shortly after, they proceeded to deploy ransomware across the environment.
C:\Windows\system32\mmc.exe C:\Windows\system32\dsa.msc 
C:\Windows\system32\mmc.exe C:\Windows\System32\gpedit.msc
An examination of logon activity within the environment revealed evidence pointing to pass-the-hash attacks.
Specifically, Windows Security logs with event ID 4624, showing logon type 9 and the Logon Process listed as “seclogo,” serve as solid indicators of the pass-the-hash technique employed by the threat actor.
The threat actor used three main methods for lateral movement.
First, Cobalt Strike utilized SMB ADMIN$ shares to move beacons laterally, along with distributing both SMB and HTTPS beacons.
Secondly, they used Remote Desktop Protocol to access a file server and a backup server, where they performed discovery activity.
Lastly, the threat actor used the hidden SMB share C$ to distribute the ransomware executable to strategic endpoints within the infrastructure.
A domain controller was used as the main pivot point by the threat actor.
Overview of lateral movement involving SMB ADMIN$ shares and RDP:
To investigate access to the SMB ADMIN$ share, the Windows event log proves invaluable.
By examining System event ID 5145, which indicates “A network share object was checked…,” We can track the movement of beacons by the threat actor across the network, gaining essential insight into their lateral movements and activities.
The RDP Activity can be identified with windows security eventID 4624 where the logon type equals 10 RemoteInteractive – “A user logged on to this computer remotely using Terminal Services or Remote Desktop.”
Windows security event ID 5145 was used to demonstrate lateral movement once again, showing SMB C$ share usage.
Cobalt Strike SMB beacons, used for lateral movement, were distributed on the beachhead and on a domain controller:
The threat actor’s use of RDP and tunnels via SystemBC left behind crucial artifacts that helped identify their activities.
Notably, we detected two hostnames, “DESKTOP-0MEMSEA” and “DESKTOP-BIFFSC7”, which were used during the intrusion.
These artifacts appeared in various logs, including Sysmon event ID 24 (clipboard change), Windows Security event ID 4624 (logon), event ID 4778 (terminal session reconnect), and event ID 4779 (terminal server disconnect), providing multiple points of evidence linking the threat actor’s presence across the environment.
The threat actor used 7z to archive data output from running the Get-DataInfo.ps1 PowerShell script.
Sysmon eventID 1 showing execution of 7z.exe archiving data:
In their pursuit of valuable data, the threat actor browsed through file systems, selectively opening files they deemed interesting.
Documents containing passwords, financial information, and other sensitive data were specifically targeted, as these types of files typically hold high value for the intruders.
Sysmon eventID 1 showing Notepad and Wordpad used to open and look at files:
For command and control, the threat actor used two main tools, Cobalt Strike and SystemBC.
Overview of Cobalt Strike traffic beaconing pattern over intrusion:
The initial Cobalt Strike beacon, delivered via RtWin64.exe on the beachhead host, maintained a continuous command and control domain at svchorst[.]com throughout the entire infection.
The IP address associated with the domain changed over time, and the communication process also shifted as queries were injected into different processes by RtWin64.exe.
To further obfuscate its presence, the threat actor initially routed the Cobalt Strike command and control traffic through CloudFlare’s CDN service, effectively attempting to hide in plain sight by blending into legitimate web traffic.
The 104[.]21.76.140 and 172[.]67.196.25 addresses belonged to Cloudflare.
Later in the intrusion, the command and control (C2) server moved away from CloudFlare, and subsequently, the domain resolved to an AWS IP address.
DNS queries performed for svchorst[.]com:
Network connections to svchorst[.]com:
Using Didier Steven’s great tool 1768.py, we successfully extracted the configuration of the Cobalt Strike beacon, which validated the host artifacts discovered on the beachhead host.
In the rest of the infrastructure, two distinct types of Cobalt Strike beacons were deployed: HTTPS beacons and SMB beacons.
The HTTPS beacons appeared to communicate with three different domains—wq[.]regsvcast[.]com, as[.]regsvcast[.]com, and zx[.]regsvcast[.]com—though, in reality, only wq[.]regsvcast[.]com was actively used, resolving to IP address 147.78.47[.]178.
This Cobalt Strike server was tracked as active by the DFIR Threat Feeds from December 21st through Jan 6th, 2024.
Sysmon event ID 22 helped document the DNS queries related to the *regsvcast[.]com domains, providing further insight into the network activity tied to the Cobalt Strike infrastructure.
Sysmon event ID 3 logs every network connection made, provided it’s not disabled in the Sysmon configuration.
This can be particularly useful, as some EDR solutions apply rate limits to this type of artifact.
Since Cobalt Strike beacons can generate significant traffic, the volume of network connections for each beacon can be observed in the final column of these logs, highlighting the frequency and noisiness of the communication between beacons and command and control infrastructure.
Below is the configuration of the beacon from DC Y which communicated encrypted over https on port 443:
One C2 connection from the Cobalt Strike beacons stands out from the rest: it originates from PowerShell but communicates over HTTP to port 80.
Communicating in clear text gives us the opportunity to look at what is going on.
The threat actor used PowerShell to perform the download:
Using Wireshark to view the exact HTTP query to the C2 server:
A PowerShell script was downloaded that decodes a Base64-encoded blob using `FromBase64String`.
At the end of the script, the decoded data is decompressed, which can easily be done using tools like `gunzip`.
This behavior is highly indicative of a Cobalt Strike PowerShell stager.
Upon decoding the Base64 blob, we uncovered another embedded PowerShell script.
This PowerShell script decodes another base64 blob, but as we can see it also performs XOR operations on the bytes.
XOR with decimal 35(0x23) is a well known key for Cobalt Strike PowerShell stagers.
After decoding the final base64 blob we get the Cobalt Strike beacon and can get the configuration (as the configuration is the same on all HTTP beacons the config is extracted with csce):
Another command and control channel utilized by the threat actor in this intrusion was SystemBC, a tool frequently favored by ransomware groups.
One of its most commonly used features is its proxy functionality.
This allowed the threat actor to leverage their own external computers and, through the SystemBC malware deployed on the file server, establish proxy connections to access the local network, facilitating further actions within the compromised environment.
The threat actor first brought in SystemBC as a file named SC.exe.
This was executed manually by the threat actor after logging into the file server from DC X.
Security EventID 4624 showing RDP logon and Logon ID:
The threat actor manually started SystemBC with name SC.exe:
Notice that the original name is different and that the LogonID is the same as from the RDP login above.
Shortly after the threat actor brought another SystemBC file, with the name socks32.exe.
That was moved to the file server from DC X.
socks32.exe moved over SMB C$ share:
Once again execution is done manually after logging in through RDP.
If the SystemBC sample is compiled without modifications, it should be feasible to extract the configuration from the implant by examining the exe file, as all information is presented in plain text.
Port and host configuration for SystemBC in the socks32.exe implant:
The threat actor’s primary objective in this case was financial gain through ransom.
They introduced an executable named qwe.exe, which we later identified as BlackSuit ransomware.
This ransomware was strategically distributed across key endpoints within the infrastructure and executed, initiating the ransom demands.
Windows security eventID 5145 shows the distribution of the BlackSuit ransom executable via SMB C$ shares:
To avoid any errors during the final stage of their operation, the threat actor refrained from manually typing the command to execute the ransomware with the necessary command line arguments.
Instead, to ensure accuracy and eliminate the risk of typos, they also moved a file named 123.txt along with qwe.exe, likely using it as a script or reference to guarantee the correct execution of the ransomware.
Windows security eventID 5145 shows distribution of 123.exe to the c:\users directory:
Movement of the 123.txt file seen from the network side.
After staging the ransomware executable qwe.exe and the helper file 123.txt, the threat actor used RDP from DC X to log onto various systems.
Once logged in, they opened 123.txt in Notepad, copied the command from the file, and executed the ransomware.
This method ensured the correct command line arguments were used, reducing the risk of mistakes during the final execution phase.
Sysmon eventID 1 showing notepad.exe opening 123.txt:
Sysmon eventID 1 showing execution of qwe.exe
